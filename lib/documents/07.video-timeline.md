# 07. Video Timeline

## Widgets

- `PageView`
  - Widget들을 page 형식으로 scroll할 수 있게 만들어 줌
  - `pageSnapping` : `false`로 설정하면 scroll 중간에 손을 떼도 page로 자동으로 이동하지 않음 (snapping 기능 off)
  - `scrollDirection`
    - scroll 방향 변경
    - 방향에 따라 snapping되는 page의 기준 size가 달라짐
- `PageView.builder`
  - `PageView`는 `children`을 한 번에 load하고 rendering 하므로 성능상 좋지 않음
  - `builder` 생성자는 실제로 화면에 나타나는 item을 `itemBuilder` method에서 반환하도록 함
  - 화면에 보이지 않는 item은 rendering 하지 않으므로 성능 이점
  - `onPageChanged` : page가 변경될 때 호출되는 callback
  - `itemCount` : item 개수 지정 -> `itemBuilder`가 이 횟수 만큼 호출되며 item 생성
- `Positioned`
  - `Positioned.fill` : top, left, right, bottom 모두 0 -> 전체를 꽉 채움
- `IgnorePointer`
  - `child`가 touch event를 받지 못하게 함
  - `child`를 통과해서 아래 widget에 event 전달

## Feature

### Infinite scroll using `PageView`

- `itemCount`를 state로 사용
- 특정 item까지 scroll하면 `itemCount`를 증가시킴
- item으로 사용할 data를 `itemCount`가 증가한 만큼 추가
- `setState()`로 rebuild

### Controlling the `PageView`

- `PageController` 사용
- 특정 page로 이동시키는 등 `PageView`의 기능을 제어할 수 있음
- Widget의 dispose 시점에 `PageController`도 `dispose()`하는 것 잊지 말 것
- API
  - `animateToPage(page,duration,curve)` : 특정 page로 이동
    - `onPageChanged` event가 발생했을 때 실행하면 기존 animation을 덮어쓰고 실행됨
    - `curve` : animation functino
      - 기본값 `decelerate`은 마지막에 animation 속도가 천천히
      - Animation 없이 넘기려면 `linear` 사용
  - `nextPage(duration,curve)` : 다음 page로 이동

### Video asset 사용하기

- `/assets/videos/~.mp4` 경로로 file 저장
- `pubspec.yaml`에서 asset 경로 추가

### Custom animation

- `AnimationController`로 custom animation을 만들고 사용함
  - 초기화
    - `vsync`는 현재 state class에 `SingleTickerProviderStateMixin`을 추가해서 설정
    - `lowerBound` : animation 시작 value
    - `upperBound` : animation 종료 value
    - `value` : animation 시작 value 초기화
    - `duration` : animation 동작 duration
  - API
    - `reverse()` : `value`를 `lowerBound`로 전환
    - `forward()` : `value`를 `upperBound`로 전환
    - `reset()` : `reverse()`처럼 `value`를 `lowerBound`로 바꾸지만, 중간 과정이 없어서 animation은 동작하지 않음
    - `addListener()`
      - `reverse()`, `forward()` 등으로 `value`가 바뀔 때, `lowerBound`와 `upperBound` 사이에 값이 변경되는 시점마다 연속적으로 callback 호출
      - `reverse()`, `forward()`만 하면 widget은 중간 단계를 알지 못하므로 animation이 동작하지 않음
      - `addListener`에서 `setState()`를 매번 호출해줘야 연속적인 animation으로 동작할 수 있다.
- Widget에서 animation 동작하는 방법
  1. `AnimationController 사용
     - `reverse()`, `forward()`로 `value` 값을 바꾸고 `setState()`로 매 frame마다 rebuild
     - `addListener`에서 `setState`로 `value` 값이 바뀌는 시점을 연속적으로 받아서 rebuild

## Package

- `video_player`
  - Flutter에서 관리하는 video player package
  - `VideoPlayerController`
    - `VideoPlayerController.asset` : local video asset 재생
    - Widget `initState()`에서 초기화 (`controller.initialize()`)
    - Widget `dispose()`에서 release (`controller.dispose()`)
    - Video 재생 (`controller.play()`)
    - Video 종료 listener 추가 (`controller.addListener`)
    - `value`로 `VideoPlayerValue`에 접근하여 video 정보 사용 (초기화 여부, metadata 등)
  - `VideoPlayerValue`
    - `isInitialized` : 초기화 여부 확인 (비동기 초기화 작업의 완료 시점 판단)
    - `duration` : video 재생시간 (`Duration`)
    - `position` : video 현재 재생 위치 (`Duration`)
- `visibility_detector`
  - 어떤 widget이 화면에 완전히 나타났는지 확인할 수 있는 package
  - `key` 필요 -> widget을 정확하게 식별하기 위함
  - `onVisibilityChanged`
    - Widget이 화면에 나타나거나 사라질 때 visibility를 `VisibilityInfo`로 전달
    - `VisibilityInfo.visibleFraction`은 0~1 사이 값으로 widget의 visibility를 나타냄
