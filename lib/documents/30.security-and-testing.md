# Security and Testing

## Firebase Security Rules

```
rules_version = '2';
service cloud.firestore {
    match /databases/{database}/documents {
        match /{document=**} {
            allow read, write
        }
    }
}
```

- Firebase가 database의 CRUD를 허용하는 규칙
- `match` : matching documents
  - 첫 번째 `match` : 모든 database들의 document에 대해
  - 두 번쨰 `match` : 모든 document에 대해
- `allow` : 허용 작업
  - `create`, `read`, `update`, `delete` : database CRUD
  - `write` : `create`, `update`, `delete`의 조합

### Security Querying

- `document=**` : 모든 document에 matching
- `match` 경로 값을 변수로 받아 사용할 수도 있다.

### `/users` collection 규칙

```
rules_version = '2';
service cloud.firestore {
    match /databases/{database}/documents {
        match /users/{document=**} {
            allow create, read, update
                : if request.auth != null && resource.id == request.auth.uid
        }
    }
}
```

- 로그인하지 않은 사용자가 `/users` collection에 document를 생성하지 못하도록 제한
- 다른 user의 document를 수정할 수 없도록 제한
- 즉, user가 본인의 id와 같은 document만 생성 및 수정할 수 있도록 허용
  - 두 번째 `match` 수정 : `/users` collection의 모든 document에 대해
  - 허용 조건 : create, read, write, update 하용
    - `request.auth != null` : 로그인한 경우에만 허용
    - `resource.id == request.auth.uid`
      - `resource` 생성되는 document
      - `/users` collection의 document id가 사용자의 user id와 같은 경우에만 허용

### `/videos` collection 규칙

```
rules_version = '2';
service cloud.firestore {
    match /databases/{database}/documents {
        // Users collection
        ...

        // Videos collection
        match /videos/{document=**} {
            allow read, create : if request.auth != null
            allow update : if request.auth != null &&
                request.auth.uid == resource.data.creatorUid
        }
    }
}
```

- 서로 다른 조건으로 작업을 허용할 수 있음
  1. 로그인한 사용자만 read, write 허용
  2. 로그인한 사용자 자기 자신의 video에 대해서만 update 허용

### `/likes` colleciton 규칙

```
match /likes/{document=**} {
    allow write :
        if request.auth != null &&
            get(/databases/$(database)/documents/users/$(request.auth.uid)).data.token != ""
}
```

- Notification token을 가진 사용자만 `/likes` collection에 document를 추가할 수 있다고 가정
- 특정 collection의 data에 접근할 수 있는 방법 필요
- `get(path)` : 특정 path에 matching되는 document에 접근. `data`로 실제 data에 접근 가능
- `exists(path)` : document를 반환하지 않고 document 존재 유무만 반환
- `get`이나 `exists`는 read operation이므로 요금이 부과될 것

## Testing

- 종류
  - Unit test : test isolated code
  - Widget test widget
  - Integration test
- 파일 이름이 반드시 "test"로 끝나야 내부 `main()` 함수를 test mode로 실행시킬 수 있음

### Unit test

- `main()` 함수 안에서 작성
- `test(descrioption,body)` 함수에서 `body`에 test code를 작성한 함수 전달
- `expect(actual,matcher)` : assertion
  - `actual`에 테스트하려는 대상을 넣고
  - `matcher`에 `Matcher` type 객체를 전달한다.
  - `Matcher` 종륲
    - `equals()`
    - `greaterThan()`
    - `isInstanceOf<Type>`
- `group(description,body)` : `test()` 여러 개를 하나로 묶을 수 있음 (구조화)

### Widget test

- `testWidgets(description,callback)` 사용
- `callback` 함수의 parameter로 전달되는 `WidgetTester` 객체 사용
  - `pump~` : app에 trigger를 발생시키는 역할
  - `pumpWidget(widget)` : test 하기 전에 `widget`의 UI를 rendering 함
- `Text`가 포함된 widget을 `pumpWidget`에서 사용할 때 문제
  - `Directionality` widget이 없다는 exception이 발생할 수 있음
  - 평소에는 `MaterialApp` 또는 `WidgetsApp`이 내부적으로 `Directionality` widget을 추가하고 있었던 것
  - Pump 하려는 widget을 `Directionality` widget으로 감싸야 함
- Widget expectation
  - `expect(actual,matcher)`로 assertion
  - `find` 객체를 사용해서 특정 요소를 검색한 뒤 `actual`에 전달
    - `find.text("test")` : "test"라는 문자열을 찾는다.
    - `find.byType(Type)` : `Type`과 일치하는 widget을 찾는다.
    - `WidgetTester.firstWidget(finder)`에 전달하면 해당 widget instance를 얻고 속성에 접근할 수 있다.
  - `findsOneWidget` 등 `Matcher` type을 반환하는 finder를 `matcher`에 전달
  - 즉, `expect(find.text("Next"), findsOneWidget)`은 위에서 `pumpWidget`으로 주입한 widget으로부터 "Next"라는 text를 가진 widget을 찾는다.
